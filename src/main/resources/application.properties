
#
# JPA (JpaBaseConfiguration, HibernateJpaAutoConfiguration)
#

spring.jpa.hibernate.ddl-auto=none
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect
spring.jpa.show-sql=false

# This is needed because Spring's naming handlers will turn CamelCase into SNAKE_CASE, even if
# the column name is specified through a Column annotation.
spring.jpa.hibernate.naming.implicit-strategy=org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImpl
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

# The classpath maps the entirety of the src/main/resources directory.
spring.jpa.mapping-resources=classpath:orm.xml

# This is bad but I'm not sure how to handle this shit when dealing with @ResponseBody
# for autogenerated queries (Repository.findAll). Maybe handle JSON serlization myself and returning that
# instead of an object? See the JSON controllers in f.f.s.m.controllers.
spring.jpa.open-in-view=true

#
# DATASOURCE (DataSourceAutoConfiguration & DataSourceProperties)
# 
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/spring_database?verifyServerCertificate=false&useSSL=false&requireSSL=false
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.username=root
spring.datasource.password=root

#
# INTERNATIONALIZATION (MessageSourceProperties)
#
spring.messages.encoding=UTF-8

#
# Make Thymeleaf/JSTL coexist

spring.view.prefix=/WEB-INF/
spring.view.suffix=.jsp
spring.view.view-names=jsp/*
spring.thymeleaf.view-names=thymeleaf/*

spring.resources.add-mappings=true